// Copyright 2008 Google Inc.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Code generated by the Protocol Buffer compiler is owned by the owner
// of the input file used when generating it.  This code is not
// standalone and requires a support library to be linked with it.  This
// support library is itself covered by the above license.

import 'dart:ffi';
import 'dart:typed_data';

import 'binary_reader.dart' show IBinaryReader;

const twoPwr32Dbl = 0x100000000;

final class Varint64 {
  @Uint32()
  int hi;

  @Uint32()
  int lo;

  Varint64(this.hi, this.lo);

  factory Varint64.fromString(String dec) {
    var bits = int64FromString(dec);
    return Varint64(bits.hi, bits.lo);
  }
}

Varint64 newBits(int lo, int hi) {
  return Varint64(hi, lo);
}

Varint64 negate(int lowBits, int highBits) {
  highBits = ~highBits;
  if (lowBits != 0) {
    lowBits = ~lowBits + 1;
  } else {
    // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,
    // adding 1 to that, results in 0x100000000, which leaves
    // the low bits 0x0 and simply adds one to the high bits.
    highBits += 1;
  }
  return newBits(lowBits, highBits);
}

({int lo, int hi}) toUnsigned(int lo, int hi) {
  return (lo: lo >>> 0, hi: hi >>> 0);
}

decimalFrom1e7WithLeadingZeros(int digit1e7) {
  final partial = digit1e7.toString();
  return "0000000".substring(partial.length) + partial;
}

uInt64ToString(int lo, int hi) {
  (:lo, :hi) = toUnsigned(lo, hi);
  // Skip the expensive conversion if the number is small enough to use the
  // built-in conversions.
  // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with
  // highBits <= 0x1FFFFF can be safely expressed with a double and retain
  // integer precision.
  // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.
  if (hi <= 0x1fffff) {
    return (twoPwr32Dbl * hi + lo).toString();
  }

  // What this code is doing is essentially converting the input number from
  // base-2 to base-1e7, which allows us to represent the 64-bit range with
  // only 3 (very large) digits. Those digits are then trivial to convert to
  // a base-10 string.

  // The magic numbers used here are -
  // 2^24 = 16777216 = (1,6777216) in base-1e7.
  // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.

  // Split 32:32 representation into 16:24:24 representation so our
  // intermediate digits don't overflow.
  final low = lo & 0xffffff;
  final mid = ((lo >>> 24) | (hi << 8)) & 0xffffff;
  final high = (hi >> 16) & 0xffff;

  // Assemble our three base-1e7 digits, ignoring carries. The maximum
  // value in a digit at this step is representable as a 48-bit integer, which
  // can be stored in a 64-bit floating point number.
  var digitA = low + mid * 6777216 + high * 6710656;
  var digitB = mid + high * 8147497;
  var digitC = high * 2;

  // Apply carries from A to B and from B to C.
  const base = 10000000;
  if (digitA >= base) {
    digitB += (digitA / base).floor();
    digitA %= base;
  }

  if (digitB >= base) {
    digitC += (digitB / base).floor();
    digitB %= base;
  }

  // If digitC is 0, then we should have returned in the trivial code path
  // at the top for non-safe integers. Given this, we can assume both digitB
  // and digitA need leading zeros.
  return digitC.toString() +
      decimalFrom1e7WithLeadingZeros(digitB) +
      decimalFrom1e7WithLeadingZeros(digitA);
}

int64ToString(int lo, int hi) {
  Varint64 bits = newBits(lo, hi);
  // If we're treating the input as a signed value and the high bit is set, do
  // a manual two's complement conversion before the decimal conversion.
  var negative = bits.hi & 0x80000000;
  if (negative != 0) {
    bits = negate(bits.lo, bits.hi);
  }
  var result = uInt64ToString(bits.lo, bits.hi);
  return negative != 0 ? "-$result" : result;
}

int64FromString(String dec) {
  // Check for minus sign.
  var minus = dec.startsWith('-');
  if (minus) {
    dec = dec.substring(1);
  }

  // Work 6 decimal digits at a time, acting like we're converting base 1e6
  // digits to binary. This is safe to do with floating point math because
  // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.
  double base = 1e6;
  int lowBits = 0;
  int highBits = 0;

  var bitPosCounter = 1;
  for (var i = 4; i > 0; i--) {
    var begin = dec.length - i * 6;
    int end;
    if (begin < 0 && begin > -6) {
      begin = 0;
      end = dec.length % 6;
    } else if (begin < 0 && begin * bitPosCounter <= -6) {
      begin = end = 0;
    } else if (begin + 6 > dec.length) {
      end = dec.length;
    } else {
      end = begin + 6;
    }
    bitPosCounter++;
    var digit1e6 = int.tryParse(
            dec.substring(begin < 0 ? 0 : begin, end < 0 ? dec.length : end)) ??
        0;
    highBits *= base.toInt();
    lowBits = lowBits * base.toInt() + digit1e6;
    // Carry bits from lowBits to
    if (lowBits >= twoPwr32Dbl) {
      highBits = highBits + ((lowBits ~/ twoPwr32Dbl) | 0);
      lowBits = lowBits % twoPwr32Dbl;
    }
  }
  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
}

/// Writes varint32 to [pos] in [buff].
///
/// [val] is the value to write.
/// [buff] is the destination buffer.
/// [pos] is the position in the buffer.
void writeVarint32(int val, Uint8List buff, @Uint32() int pos) {
  while (val > 127) {
    buff[pos++] = (val & 127) | 128;
    val >>>= 7;
  }
  buff[pos] = val;
}

/// Reads a unsigned varint32 from
///
/// [reader] is the binary reader to read from.
///
/// See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220
int varint32read(IBinaryReader reader) {
  var result = 0;
  var b;
  for (var i = 0; i < 4; i++) {
    b = reader.buffer[reader.position++];
    result |= (b & 0x7f) << (i * 7);
    if ((b & 0x80) == 0) {
      reader.assertBounds();
      return result;
    }
  }
  b = reader.buffer[reader.position++];
  result |= (b & 0x0f) << 28;

  for (var readBytes = 5; (b & 0x80) != 0 && readBytes < 10; readBytes++) {
    b = reader.buffer[reader.position++];
  }
  if ((b & 0x80) != 0) throw Exception('Invalid varint');
  reader.assertBounds();

  // fills Dart's bits
  if (b & 0xFE == 0) {
    for (var i = 0; i < 8; i++) {
      result |= (0xffff) << (32 + (i * 8));
    }
  }

  // Result can have 32 bits, convert it to unsigned
  return result >>> 0;
}

void writeVarint64(Varint64 val, Uint8List buf, int pos) {
  val.hi >>>=
      32; // Adjust to Dart's int representation, Negative on bit 63 is moved to bit 31.
  while (val.hi != 0) {
    buf[pos++] = (val.lo & 127) | 128;
    val.lo = (val.lo >>> 7) | (val.hi << 25);
    val.hi = val.hi >>> 7;
  }
  while (val.lo > 127) {
    buf[pos++] = (val.lo & 127) | 128;
    val.lo = val.lo >>> 7;
  }
  buf[pos++] = val.lo;
}

varint64read(IBinaryReader reader) {
  var lowBits = 0;
  var highBits = 0;

  for (var shift = 0; shift < 28; shift += 7) {
    var b = reader.buffer[reader.position++];
    lowBits |= (b & 0x7f) << shift;
    if ((b & 0x80) == 0) {
      reader.assertBounds();
      return [lowBits, highBits];
    }
  }

  var middleByte = reader.buffer[reader.position++];

  // last four bits of the first 32 bit number
  lowBits |= (middleByte & 0x0f) << 28;

  // 3 upper bits are part of the next 32 bit number
  highBits = (middleByte & 0x70) >> 4;

  if ((middleByte & 0x80) == 0) {
    reader.assertBounds();
    return [lowBits, highBits];
  }

  for (var shift = 3; shift <= 31; shift += 7) {
    var b = reader.buffer[reader.position++];
    highBits |= (b & 0x7f) << shift;
    if ((b & 0x80) == 0) {
      reader.assertBounds();
      return [lowBits, highBits];
    }
  }

  throw Exception('Invalid varint64');
}

/// Signed int32 without moving to pos
///
/// [buffer] is the source buffer.
/// [pos] is the position in the buffer.
@Int32()
int readInt32(Uint8List buffer, int pos) {
  return (buffer[pos] |
          (buffer[pos + 1] << 8) |
          (buffer[pos + 2] << 16) |
          (buffer[pos + 3] << 24)) >>>
      0;
}
